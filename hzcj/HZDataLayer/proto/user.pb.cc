// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "user.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace QuoteProto {

namespace {

const ::google::protobuf::Descriptor* FirstConnectRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FirstConnectRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* FirstConnectResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FirstConnectResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* UserLoginRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UserLoginRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* UserLoginResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UserLoginResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* UserKickMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UserKickMsg_reflection_ = NULL;
const ::google::protobuf::Descriptor* UploadLoginInfoRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UploadLoginInfoRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* UserPermissionErrMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UserPermissionErrMsg_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* LoginRetType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_user_2eproto() {
  protobuf_AddDesc_user_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "user.proto");
  GOOGLE_CHECK(file != NULL);
  FirstConnectRequest_descriptor_ = file->message_type(0);
  static const int FirstConnectRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirstConnectRequest, aeskey_),
  };
  FirstConnectRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FirstConnectRequest_descriptor_,
      FirstConnectRequest::default_instance_,
      FirstConnectRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirstConnectRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirstConnectRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FirstConnectRequest));
  FirstConnectResponse_descriptor_ = file->message_type(1);
  static const int FirstConnectResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirstConnectResponse, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirstConnectResponse, pubkey_),
  };
  FirstConnectResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FirstConnectResponse_descriptor_,
      FirstConnectResponse::default_instance_,
      FirstConnectResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirstConnectResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirstConnectResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FirstConnectResponse));
  UserLoginRequest_descriptor_ = file->message_type(2);
  static const int UserLoginRequest_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserLoginRequest, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserLoginRequest, password_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserLoginRequest, token_),
  };
  UserLoginRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UserLoginRequest_descriptor_,
      UserLoginRequest::default_instance_,
      UserLoginRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserLoginRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserLoginRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UserLoginRequest));
  UserLoginResponse_descriptor_ = file->message_type(3);
  static const int UserLoginResponse_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserLoginResponse, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserLoginResponse, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserLoginResponse, kick_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserLoginResponse, permissions_),
  };
  UserLoginResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UserLoginResponse_descriptor_,
      UserLoginResponse::default_instance_,
      UserLoginResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserLoginResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserLoginResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UserLoginResponse));
  UserKickMsg_descriptor_ = file->message_type(4);
  static const int UserKickMsg_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserKickMsg, kick_info_),
  };
  UserKickMsg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UserKickMsg_descriptor_,
      UserKickMsg::default_instance_,
      UserKickMsg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserKickMsg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserKickMsg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UserKickMsg));
  UploadLoginInfoRequest_descriptor_ = file->message_type(5);
  static const int UploadLoginInfoRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UploadLoginInfoRequest, login_users_),
  };
  UploadLoginInfoRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UploadLoginInfoRequest_descriptor_,
      UploadLoginInfoRequest::default_instance_,
      UploadLoginInfoRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UploadLoginInfoRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UploadLoginInfoRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UploadLoginInfoRequest));
  UserPermissionErrMsg_descriptor_ = file->message_type(6);
  static const int UserPermissionErrMsg_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserPermissionErrMsg, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserPermissionErrMsg, seq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserPermissionErrMsg, permission_id_),
  };
  UserPermissionErrMsg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UserPermissionErrMsg_descriptor_,
      UserPermissionErrMsg::default_instance_,
      UserPermissionErrMsg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserPermissionErrMsg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserPermissionErrMsg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UserPermissionErrMsg));
  LoginRetType_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_user_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FirstConnectRequest_descriptor_, &FirstConnectRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FirstConnectResponse_descriptor_, &FirstConnectResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UserLoginRequest_descriptor_, &UserLoginRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UserLoginResponse_descriptor_, &UserLoginResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UserKickMsg_descriptor_, &UserKickMsg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UploadLoginInfoRequest_descriptor_, &UploadLoginInfoRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UserPermissionErrMsg_descriptor_, &UserPermissionErrMsg::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_user_2eproto() {
  delete FirstConnectRequest::default_instance_;
  delete FirstConnectRequest_reflection_;
  delete FirstConnectResponse::default_instance_;
  delete FirstConnectResponse_reflection_;
  delete UserLoginRequest::default_instance_;
  delete UserLoginRequest_reflection_;
  delete UserLoginResponse::default_instance_;
  delete UserLoginResponse_reflection_;
  delete UserKickMsg::default_instance_;
  delete UserKickMsg_reflection_;
  delete UploadLoginInfoRequest::default_instance_;
  delete UploadLoginInfoRequest_reflection_;
  delete UserPermissionErrMsg::default_instance_;
  delete UserPermissionErrMsg_reflection_;
}

void protobuf_AddDesc_user_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::QuoteProto::protobuf_AddDesc_ret_5fbase_2eproto();
  ::QuoteProto::protobuf_AddDesc_public_5fmessage_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\nuser.proto\022\nQuoteProto\032\016ret_base.proto"
    "\032\024public_message.proto\"%\n\023FirstConnectRe"
    "quest\022\016\n\006aeskey\030\001 \002(\t\"D\n\024FirstConnectRes"
    "ponse\022\034\n\003ret\030\001 \002(\0132\017.QuoteProto.Ret\022\016\n\006p"
    "ubkey\030\002 \001(\t\"@\n\020UserLoginRequest\022\013\n\003uid\030\001"
    " \002(\004\022\020\n\010password\030\002 \001(\t\022\r\n\005token\030\003 \001(\t\"\245\001"
    "\n\021UserLoginResponse\022\034\n\003ret\030\001 \002(\0132\017.Quote"
    "Proto.Ret\022\013\n\003uid\030\002 \002(\004\0220\n\tkick_info\030\003 \001("
    "\0132\035.QuoteProto.UserLoginKickInfo\0223\n\013perm"
    "issions\030\004 \001(\0132\036.QuoteProto.UserPermissio"
    "nInfo\"\?\n\013UserKickMsg\0220\n\tkick_info\030\001 \002(\0132"
    "\035.QuoteProto.UserLoginKickInfo\"H\n\026Upload"
    "LoginInfoRequest\022.\n\013login_users\030\001 \003(\0132\031."
    "QuoteProto.UserLoginInfo\"G\n\024UserPermissi"
    "onErrMsg\022\013\n\003cmd\030\001 \001(\r\022\013\n\003seq\030\002 \001(\r\022\025\n\rpe"
    "rmission_id\030\003 \001(\005*.\n\014LoginRetType\022\013\n\007suc"
    "cess\020\000\022\021\n\rdevice_repeat\020\001", 665);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "user.proto", &protobuf_RegisterTypes);
  FirstConnectRequest::default_instance_ = new FirstConnectRequest();
  FirstConnectResponse::default_instance_ = new FirstConnectResponse();
  UserLoginRequest::default_instance_ = new UserLoginRequest();
  UserLoginResponse::default_instance_ = new UserLoginResponse();
  UserKickMsg::default_instance_ = new UserKickMsg();
  UploadLoginInfoRequest::default_instance_ = new UploadLoginInfoRequest();
  UserPermissionErrMsg::default_instance_ = new UserPermissionErrMsg();
  FirstConnectRequest::default_instance_->InitAsDefaultInstance();
  FirstConnectResponse::default_instance_->InitAsDefaultInstance();
  UserLoginRequest::default_instance_->InitAsDefaultInstance();
  UserLoginResponse::default_instance_->InitAsDefaultInstance();
  UserKickMsg::default_instance_->InitAsDefaultInstance();
  UploadLoginInfoRequest::default_instance_->InitAsDefaultInstance();
  UserPermissionErrMsg::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_user_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_user_2eproto {
  StaticDescriptorInitializer_user_2eproto() {
    protobuf_AddDesc_user_2eproto();
  }
} static_descriptor_initializer_user_2eproto_;

const ::google::protobuf::EnumDescriptor* LoginRetType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoginRetType_descriptor_;
}
bool LoginRetType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int FirstConnectRequest::kAeskeyFieldNumber;
#endif  // !_MSC_VER

FirstConnectRequest::FirstConnectRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FirstConnectRequest::InitAsDefaultInstance() {
}

FirstConnectRequest::FirstConnectRequest(const FirstConnectRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FirstConnectRequest::SharedCtor() {
  _cached_size_ = 0;
  aeskey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FirstConnectRequest::~FirstConnectRequest() {
  SharedDtor();
}

void FirstConnectRequest::SharedDtor() {
  if (aeskey_ != &::google::protobuf::internal::kEmptyString) {
    delete aeskey_;
  }
  if (this != default_instance_) {
  }
}

void FirstConnectRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FirstConnectRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FirstConnectRequest_descriptor_;
}

const FirstConnectRequest& FirstConnectRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_user_2eproto();  return *default_instance_;
}

FirstConnectRequest* FirstConnectRequest::default_instance_ = NULL;

FirstConnectRequest* FirstConnectRequest::New() const {
  return new FirstConnectRequest;
}

void FirstConnectRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_aeskey()) {
      if (aeskey_ != &::google::protobuf::internal::kEmptyString) {
        aeskey_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FirstConnectRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string aeskey = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_aeskey()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->aeskey().data(), this->aeskey().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FirstConnectRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string aeskey = 1;
  if (has_aeskey()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->aeskey().data(), this->aeskey().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->aeskey(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FirstConnectRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string aeskey = 1;
  if (has_aeskey()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->aeskey().data(), this->aeskey().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->aeskey(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FirstConnectRequest::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string aeskey = 1;
    if (has_aeskey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->aeskey());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FirstConnectRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FirstConnectRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FirstConnectRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FirstConnectRequest::MergeFrom(const FirstConnectRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_aeskey()) {
      set_aeskey(from.aeskey());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FirstConnectRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FirstConnectRequest::CopyFrom(const FirstConnectRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FirstConnectRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void FirstConnectRequest::Swap(FirstConnectRequest* other) {
  if (other != this) {
    std::swap(aeskey_, other->aeskey_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FirstConnectRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FirstConnectRequest_descriptor_;
  metadata.reflection = FirstConnectRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FirstConnectResponse::kRetFieldNumber;
const int FirstConnectResponse::kPubkeyFieldNumber;
#endif  // !_MSC_VER

FirstConnectResponse::FirstConnectResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FirstConnectResponse::InitAsDefaultInstance() {
  ret_ = const_cast< ::QuoteProto::Ret*>(&::QuoteProto::Ret::default_instance());
}

FirstConnectResponse::FirstConnectResponse(const FirstConnectResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FirstConnectResponse::SharedCtor() {
  _cached_size_ = 0;
  ret_ = NULL;
  pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FirstConnectResponse::~FirstConnectResponse() {
  SharedDtor();
}

void FirstConnectResponse::SharedDtor() {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete pubkey_;
  }
  if (this != default_instance_) {
    delete ret_;
  }
}

void FirstConnectResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FirstConnectResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FirstConnectResponse_descriptor_;
}

const FirstConnectResponse& FirstConnectResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_user_2eproto();  return *default_instance_;
}

FirstConnectResponse* FirstConnectResponse::default_instance_ = NULL;

FirstConnectResponse* FirstConnectResponse::New() const {
  return new FirstConnectResponse;
}

void FirstConnectResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_ret()) {
      if (ret_ != NULL) ret_->::QuoteProto::Ret::Clear();
    }
    if (has_pubkey()) {
      if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
        pubkey_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FirstConnectResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .QuoteProto.Ret ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ret()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_pubkey;
        break;
      }
      
      // optional string pubkey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pubkey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pubkey()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pubkey().data(), this->pubkey().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FirstConnectResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .QuoteProto.Ret ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->ret(), output);
  }
  
  // optional string pubkey = 2;
  if (has_pubkey()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pubkey().data(), this->pubkey().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->pubkey(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FirstConnectResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .QuoteProto.Ret ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->ret(), target);
  }
  
  // optional string pubkey = 2;
  if (has_pubkey()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pubkey().data(), this->pubkey().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->pubkey(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FirstConnectResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .QuoteProto.Ret ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ret());
    }
    
    // optional string pubkey = 2;
    if (has_pubkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pubkey());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FirstConnectResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FirstConnectResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FirstConnectResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FirstConnectResponse::MergeFrom(const FirstConnectResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      mutable_ret()->::QuoteProto::Ret::MergeFrom(from.ret());
    }
    if (from.has_pubkey()) {
      set_pubkey(from.pubkey());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FirstConnectResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FirstConnectResponse::CopyFrom(const FirstConnectResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FirstConnectResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_ret()) {
    if (!this->ret().IsInitialized()) return false;
  }
  return true;
}

void FirstConnectResponse::Swap(FirstConnectResponse* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(pubkey_, other->pubkey_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FirstConnectResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FirstConnectResponse_descriptor_;
  metadata.reflection = FirstConnectResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UserLoginRequest::kUidFieldNumber;
const int UserLoginRequest::kPasswordFieldNumber;
const int UserLoginRequest::kTokenFieldNumber;
#endif  // !_MSC_VER

UserLoginRequest::UserLoginRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UserLoginRequest::InitAsDefaultInstance() {
}

UserLoginRequest::UserLoginRequest(const UserLoginRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UserLoginRequest::SharedCtor() {
  _cached_size_ = 0;
  uid_ = GOOGLE_ULONGLONG(0);
  password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserLoginRequest::~UserLoginRequest() {
  SharedDtor();
}

void UserLoginRequest::SharedDtor() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (this != default_instance_) {
  }
}

void UserLoginRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UserLoginRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UserLoginRequest_descriptor_;
}

const UserLoginRequest& UserLoginRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_user_2eproto();  return *default_instance_;
}

UserLoginRequest* UserLoginRequest::default_instance_ = NULL;

UserLoginRequest* UserLoginRequest::New() const {
  return new UserLoginRequest;
}

void UserLoginRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = GOOGLE_ULONGLONG(0);
    if (has_password()) {
      if (password_ != &::google::protobuf::internal::kEmptyString) {
        password_->clear();
      }
    }
    if (has_token()) {
      if (token_ != &::google::protobuf::internal::kEmptyString) {
        token_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UserLoginRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_password;
        break;
      }
      
      // optional string password = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->password().data(), this->password().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_token;
        break;
      }
      
      // optional string token = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_token:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_token()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->token().data(), this->token().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserLoginRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uid(), output);
  }
  
  // optional string password = 2;
  if (has_password()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->password().data(), this->password().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->password(), output);
  }
  
  // optional string token = 3;
  if (has_token()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->token().data(), this->token().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->token(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UserLoginRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->uid(), target);
  }
  
  // optional string password = 2;
  if (has_password()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->password().data(), this->password().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->password(), target);
  }
  
  // optional string token = 3;
  if (has_token()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->token().data(), this->token().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->token(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UserLoginRequest::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uid());
    }
    
    // optional string password = 2;
    if (has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->password());
    }
    
    // optional string token = 3;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->token());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserLoginRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UserLoginRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UserLoginRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UserLoginRequest::MergeFrom(const UserLoginRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_password()) {
      set_password(from.password());
    }
    if (from.has_token()) {
      set_token(from.token());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UserLoginRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UserLoginRequest::CopyFrom(const UserLoginRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserLoginRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void UserLoginRequest::Swap(UserLoginRequest* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(password_, other->password_);
    std::swap(token_, other->token_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UserLoginRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UserLoginRequest_descriptor_;
  metadata.reflection = UserLoginRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UserLoginResponse::kRetFieldNumber;
const int UserLoginResponse::kUidFieldNumber;
const int UserLoginResponse::kKickInfoFieldNumber;
const int UserLoginResponse::kPermissionsFieldNumber;
#endif  // !_MSC_VER

UserLoginResponse::UserLoginResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UserLoginResponse::InitAsDefaultInstance() {
  ret_ = const_cast< ::QuoteProto::Ret*>(&::QuoteProto::Ret::default_instance());
  kick_info_ = const_cast< ::QuoteProto::UserLoginKickInfo*>(&::QuoteProto::UserLoginKickInfo::default_instance());
  permissions_ = const_cast< ::QuoteProto::UserPermissionInfo*>(&::QuoteProto::UserPermissionInfo::default_instance());
}

UserLoginResponse::UserLoginResponse(const UserLoginResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UserLoginResponse::SharedCtor() {
  _cached_size_ = 0;
  ret_ = NULL;
  uid_ = GOOGLE_ULONGLONG(0);
  kick_info_ = NULL;
  permissions_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserLoginResponse::~UserLoginResponse() {
  SharedDtor();
}

void UserLoginResponse::SharedDtor() {
  if (this != default_instance_) {
    delete ret_;
    delete kick_info_;
    delete permissions_;
  }
}

void UserLoginResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UserLoginResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UserLoginResponse_descriptor_;
}

const UserLoginResponse& UserLoginResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_user_2eproto();  return *default_instance_;
}

UserLoginResponse* UserLoginResponse::default_instance_ = NULL;

UserLoginResponse* UserLoginResponse::New() const {
  return new UserLoginResponse;
}

void UserLoginResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_ret()) {
      if (ret_ != NULL) ret_->::QuoteProto::Ret::Clear();
    }
    uid_ = GOOGLE_ULONGLONG(0);
    if (has_kick_info()) {
      if (kick_info_ != NULL) kick_info_->::QuoteProto::UserLoginKickInfo::Clear();
    }
    if (has_permissions()) {
      if (permissions_ != NULL) permissions_->::QuoteProto::UserPermissionInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UserLoginResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .QuoteProto.Ret ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ret()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_uid;
        break;
      }
      
      // required uint64 uid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_uid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_kick_info;
        break;
      }
      
      // optional .QuoteProto.UserLoginKickInfo kick_info = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_kick_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kick_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_permissions;
        break;
      }
      
      // optional .QuoteProto.UserPermissionInfo permissions = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_permissions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_permissions()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserLoginResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .QuoteProto.Ret ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->ret(), output);
  }
  
  // required uint64 uid = 2;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->uid(), output);
  }
  
  // optional .QuoteProto.UserLoginKickInfo kick_info = 3;
  if (has_kick_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->kick_info(), output);
  }
  
  // optional .QuoteProto.UserPermissionInfo permissions = 4;
  if (has_permissions()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->permissions(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UserLoginResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .QuoteProto.Ret ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->ret(), target);
  }
  
  // required uint64 uid = 2;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->uid(), target);
  }
  
  // optional .QuoteProto.UserLoginKickInfo kick_info = 3;
  if (has_kick_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->kick_info(), target);
  }
  
  // optional .QuoteProto.UserPermissionInfo permissions = 4;
  if (has_permissions()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->permissions(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UserLoginResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .QuoteProto.Ret ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ret());
    }
    
    // required uint64 uid = 2;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uid());
    }
    
    // optional .QuoteProto.UserLoginKickInfo kick_info = 3;
    if (has_kick_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->kick_info());
    }
    
    // optional .QuoteProto.UserPermissionInfo permissions = 4;
    if (has_permissions()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->permissions());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserLoginResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UserLoginResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UserLoginResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UserLoginResponse::MergeFrom(const UserLoginResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      mutable_ret()->::QuoteProto::Ret::MergeFrom(from.ret());
    }
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_kick_info()) {
      mutable_kick_info()->::QuoteProto::UserLoginKickInfo::MergeFrom(from.kick_info());
    }
    if (from.has_permissions()) {
      mutable_permissions()->::QuoteProto::UserPermissionInfo::MergeFrom(from.permissions());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UserLoginResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UserLoginResponse::CopyFrom(const UserLoginResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserLoginResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_ret()) {
    if (!this->ret().IsInitialized()) return false;
  }
  return true;
}

void UserLoginResponse::Swap(UserLoginResponse* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(uid_, other->uid_);
    std::swap(kick_info_, other->kick_info_);
    std::swap(permissions_, other->permissions_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UserLoginResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UserLoginResponse_descriptor_;
  metadata.reflection = UserLoginResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UserKickMsg::kKickInfoFieldNumber;
#endif  // !_MSC_VER

UserKickMsg::UserKickMsg()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UserKickMsg::InitAsDefaultInstance() {
  kick_info_ = const_cast< ::QuoteProto::UserLoginKickInfo*>(&::QuoteProto::UserLoginKickInfo::default_instance());
}

UserKickMsg::UserKickMsg(const UserKickMsg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UserKickMsg::SharedCtor() {
  _cached_size_ = 0;
  kick_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserKickMsg::~UserKickMsg() {
  SharedDtor();
}

void UserKickMsg::SharedDtor() {
  if (this != default_instance_) {
    delete kick_info_;
  }
}

void UserKickMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UserKickMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UserKickMsg_descriptor_;
}

const UserKickMsg& UserKickMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_user_2eproto();  return *default_instance_;
}

UserKickMsg* UserKickMsg::default_instance_ = NULL;

UserKickMsg* UserKickMsg::New() const {
  return new UserKickMsg;
}

void UserKickMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_kick_info()) {
      if (kick_info_ != NULL) kick_info_->::QuoteProto::UserLoginKickInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UserKickMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .QuoteProto.UserLoginKickInfo kick_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kick_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserKickMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .QuoteProto.UserLoginKickInfo kick_info = 1;
  if (has_kick_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->kick_info(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UserKickMsg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .QuoteProto.UserLoginKickInfo kick_info = 1;
  if (has_kick_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->kick_info(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UserKickMsg::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .QuoteProto.UserLoginKickInfo kick_info = 1;
    if (has_kick_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->kick_info());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserKickMsg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UserKickMsg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UserKickMsg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UserKickMsg::MergeFrom(const UserKickMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kick_info()) {
      mutable_kick_info()->::QuoteProto::UserLoginKickInfo::MergeFrom(from.kick_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UserKickMsg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UserKickMsg::CopyFrom(const UserKickMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserKickMsg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void UserKickMsg::Swap(UserKickMsg* other) {
  if (other != this) {
    std::swap(kick_info_, other->kick_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UserKickMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UserKickMsg_descriptor_;
  metadata.reflection = UserKickMsg_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UploadLoginInfoRequest::kLoginUsersFieldNumber;
#endif  // !_MSC_VER

UploadLoginInfoRequest::UploadLoginInfoRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UploadLoginInfoRequest::InitAsDefaultInstance() {
}

UploadLoginInfoRequest::UploadLoginInfoRequest(const UploadLoginInfoRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UploadLoginInfoRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UploadLoginInfoRequest::~UploadLoginInfoRequest() {
  SharedDtor();
}

void UploadLoginInfoRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UploadLoginInfoRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UploadLoginInfoRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UploadLoginInfoRequest_descriptor_;
}

const UploadLoginInfoRequest& UploadLoginInfoRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_user_2eproto();  return *default_instance_;
}

UploadLoginInfoRequest* UploadLoginInfoRequest::default_instance_ = NULL;

UploadLoginInfoRequest* UploadLoginInfoRequest::New() const {
  return new UploadLoginInfoRequest;
}

void UploadLoginInfoRequest::Clear() {
  login_users_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UploadLoginInfoRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .QuoteProto.UserLoginInfo login_users = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_login_users:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_login_users()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_login_users;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UploadLoginInfoRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .QuoteProto.UserLoginInfo login_users = 1;
  for (int i = 0; i < this->login_users_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->login_users(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UploadLoginInfoRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .QuoteProto.UserLoginInfo login_users = 1;
  for (int i = 0; i < this->login_users_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->login_users(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UploadLoginInfoRequest::ByteSize() const {
  int total_size = 0;
  
  // repeated .QuoteProto.UserLoginInfo login_users = 1;
  total_size += 1 * this->login_users_size();
  for (int i = 0; i < this->login_users_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->login_users(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UploadLoginInfoRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UploadLoginInfoRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UploadLoginInfoRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UploadLoginInfoRequest::MergeFrom(const UploadLoginInfoRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  login_users_.MergeFrom(from.login_users_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UploadLoginInfoRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UploadLoginInfoRequest::CopyFrom(const UploadLoginInfoRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UploadLoginInfoRequest::IsInitialized() const {
  
  for (int i = 0; i < login_users_size(); i++) {
    if (!this->login_users(i).IsInitialized()) return false;
  }
  return true;
}

void UploadLoginInfoRequest::Swap(UploadLoginInfoRequest* other) {
  if (other != this) {
    login_users_.Swap(&other->login_users_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UploadLoginInfoRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UploadLoginInfoRequest_descriptor_;
  metadata.reflection = UploadLoginInfoRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UserPermissionErrMsg::kCmdFieldNumber;
const int UserPermissionErrMsg::kSeqFieldNumber;
const int UserPermissionErrMsg::kPermissionIdFieldNumber;
#endif  // !_MSC_VER

UserPermissionErrMsg::UserPermissionErrMsg()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UserPermissionErrMsg::InitAsDefaultInstance() {
}

UserPermissionErrMsg::UserPermissionErrMsg(const UserPermissionErrMsg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UserPermissionErrMsg::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 0u;
  seq_ = 0u;
  permission_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserPermissionErrMsg::~UserPermissionErrMsg() {
  SharedDtor();
}

void UserPermissionErrMsg::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UserPermissionErrMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UserPermissionErrMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UserPermissionErrMsg_descriptor_;
}

const UserPermissionErrMsg& UserPermissionErrMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_user_2eproto();  return *default_instance_;
}

UserPermissionErrMsg* UserPermissionErrMsg::default_instance_ = NULL;

UserPermissionErrMsg* UserPermissionErrMsg::New() const {
  return new UserPermissionErrMsg;
}

void UserPermissionErrMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    cmd_ = 0u;
    seq_ = 0u;
    permission_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UserPermissionErrMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 cmd = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cmd_)));
          set_has_cmd();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_seq;
        break;
      }
      
      // optional uint32 seq = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_permission_id;
        break;
      }
      
      // optional int32 permission_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_permission_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &permission_id_)));
          set_has_permission_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserPermissionErrMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 cmd = 1;
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->cmd(), output);
  }
  
  // optional uint32 seq = 2;
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->seq(), output);
  }
  
  // optional int32 permission_id = 3;
  if (has_permission_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->permission_id(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UserPermissionErrMsg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 cmd = 1;
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->cmd(), target);
  }
  
  // optional uint32 seq = 2;
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->seq(), target);
  }
  
  // optional int32 permission_id = 3;
  if (has_permission_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->permission_id(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UserPermissionErrMsg::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 cmd = 1;
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cmd());
    }
    
    // optional uint32 seq = 2;
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->seq());
    }
    
    // optional int32 permission_id = 3;
    if (has_permission_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->permission_id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserPermissionErrMsg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UserPermissionErrMsg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UserPermissionErrMsg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UserPermissionErrMsg::MergeFrom(const UserPermissionErrMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_seq()) {
      set_seq(from.seq());
    }
    if (from.has_permission_id()) {
      set_permission_id(from.permission_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UserPermissionErrMsg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UserPermissionErrMsg::CopyFrom(const UserPermissionErrMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserPermissionErrMsg::IsInitialized() const {
  
  return true;
}

void UserPermissionErrMsg::Swap(UserPermissionErrMsg* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(seq_, other->seq_);
    std::swap(permission_id_, other->permission_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UserPermissionErrMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UserPermissionErrMsg_descriptor_;
  metadata.reflection = UserPermissionErrMsg_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace QuoteProto

// @@protoc_insertion_point(global_scope)
